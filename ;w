""" Kind of an NDSolve replacement for sympy

Plan: a class called ODESolver. Takes a symbollic dy_dt as input, as well as as
python or symbollic functions for indep variables
It will/can:
    1. Do some preprocessing to simplify and eliminate unchanging state
        variables
    2. Will prepare a fast(ish) function that evaluates the derivative, and
        only evolves the necessary bits
    3. Gives an interface to solvers to actually do the integration, given initial variables
    4. Can process the output back into the original format.
    5. Optionally takes a list of actually desired outputs, so that others potentially don't have to be calculated.


# Notes for various builtins

# Decomposition into real and imaginary parameters
In general, the equations we use(especially master equations) will will have
both real and complex state variables and paramters. The simplest way to deal
with this is to make everything complex, and use an ODE solver that supports complex arithmetic. This is the default approach, but is obviously not generally optimal. However by setting
bDecompose_to_re_im, we will instead attempt to decompose all equations into
real and imaginary parts, resulting in a larger system of only real equations.

This means the following changes should be attempted by code:
* when __init__ is called, the type of symbols will be used to determine the final
    call signature. The equation dict(dy_dtD) will be decomposed.
* when set_driving is called, symbols that aren't exiplicitly set as 'real' will have
    their functions re - wrapped into two: to take the real and imaginary parts.
* when set_state_dep_funcs is called, any functions will be re - wrapped to take the new
 call signature(of pure real values)
* when set_inititial_values is called, complex(non - real) parameters will be expanded
"""
import sympy as sm
import numpy as np
from numpy import linspace, arange
import pdb
from munch import Munch, munchify
from scipy import integrate
from .import utils as ut

#import tfdiffeq
from itertools import chain
from collections.abc import Mapping


#NOTE: This class (ODESolver) is very bloated, and needs stripping back. Trying to put most of it's functionality into the above.
# The new ides is... (thought s in progress):
# * This is more of an ODEDefinition, or ODESys. or ODEinterface... or maybe Model??
# * The actual work will be done by a Model object (which could be called a Solver???)
# * The job of this thing is to handle the definitions, creating an optimised object for solving the system, and providing a convenient interface to get translate the output of it (maybe)
# * Typical usage:
#   sys = ODESys(dy_dtD, dims={})
#   sys.set_driving()
#   sys.set_initial_conditions()
#   sys.set_state_dependence()
#   sys.set_outputs()
#   model = sys.setup_model()
#   model.integrate_to()
class ODESys:
    """
    """
    #lambdify_modules = [{'conjugate':tf.math.conj}, 'tensorflow']
    lambdify_modules = ['numpy']
    #backend = 'tensorflow'
    backend = 'numpy'
    stateDepSubsD = {}
    stateDepFD = {}
    tDepSubsD = {}
    tDepFD = {}
    _online_process_func = None

    def __init__(self, dy_dtD, dims={}, tSym=sm.symbols('t'), driving_syms=[],
                 state_dep_syms=[],
                 bDecompose_to_re_im=False, backend='numpy', default_dtype=np.complex128):
        self.backend = backend

        self.dimAxes = list(dims.values())
        self.dimSyms = list(dims.keys())
        self.dim_shape = tuple([dim.size for dim in self.dimAxes]) if len(self.dimAxes) else 1
        self.dims = preShaped_dimAxes = [dAx.reshape(*(k * [1] + [dAx.size] + (len(self.dimAxes) - k - 1) * [1]))
                                 for k, dAx in enumerate(self.dimAxes)]
        self.tSym = tSym
        # np.float64 if bDecompose_to_re_im else np.complex128
        self.default_dtype = default_dtype

        # Take care of any python data types
        dy_dtD = {sym: sm.sympify(ex) for sym, ex in dy_dtD.items()}
        if bDecompose_to_re_im:
            propagated_state_syms, stationary_state_syms, indep_syms = self.sort_symbols(
                dy_dtD)
            self.symsD_orig = munchify({'tSym': self.tSym,
                                        'dimSyms': self.dimSyms,
                                        'prop_state_syms': propagated_state_syms,
                                        'stationary_state_syms': stationary_state_syms,  # Not yet used
                                        'driving_syms': driving_syms,
                                        'state_dep_syms': ut.list_diff(indep_syms, driving_syms),
                                        })
            #input_syms = driving_syms + state_dep_syms
            lhs_syms_orig = list(dy_dtD.keys())
            dy_dtD, complex_subsD, symbol_mapD = ut.expand_to_re_im(dy_dtD)
            self.complex_subsD = complex_subsD
            self.symbol_mapD = symbol_mapD
            self.state_func_sig_orig = [self.tSym] + self.dimSyms + list(propagated_state_syms) + \
                list(stationary_state_syms) + driving_syms
            # should put this all under an attribute, e.g. self.re_im_decomp

        self.dy_dtD = dy_dtD
        self.sim_size = int(len(dy_dtD) * np.product(self.dim_shape))
        self.state_shape = tuple(
            [len(dy_dtD)] + [dim.size for dim in self.dimAxes])
        self.bDecompose_to_re_im = bDecompose_to_re_im

        propagated_state_syms, stationary_state_syms, indep_syms = self.sort_symbols(
            dy_dtD)
        self.symsD = munchify({'tSym': self.tSym,
                               'dimSyms': self.dimSyms,
                               'prop_state_syms': propagated_state_syms,
                               'stationary_state_syms': stationary_state_syms,  # Not yet used
                               'driving_syms': driving_syms,
                               'state_dep_syms': ut.list_diff(indep_syms, driving_syms),
                               })

        state_func_sig = [self.tSym] + self.dimSyms + list(propagated_state_syms) + \
            list(stationary_state_syms) + driving_syms
        if bDecompose_to_re_im:
            def ensure_list(el): return el if np.iterable(el) else [el]
            # expand_to_re_im(state_func_sig)
            state_func_sig = [ensure_list(symbol_mapD[sym])
                              if sym in symbol_mapD else sym for sym in state_func_sig]
            state_func_sig = chain(*state_func_sig)
        self.state_func_sig = state_func_sig

        print(self.symsD)
        print("state dependent functions should have signature {}".format(
            self.state_func_sig))

        if self.backend == 'tensorflow':
            import tensorflow
            import tensorflow_probability as tfp
            global tf
            tf = tensorflow
            tf.keras.backend.set_floatx(TF_DTYPE) # Presumably can get more speed, especially on a GPU, 

    @staticmethod
    def sort_symbols(eqD):
        """ Sort symbols in a system of equations defined by eqD.

        What it's supposed to do:
        Take a dict defining symbols (LHS) and their derivatives (RHS), and sort out:
            1. Which LHS symbols don't change (have a zero derivative)
            2. Which RHS symbols need specifying, that is will need to be defined externally
            3. If there are any LHS symbols that don't appear elsewhere and thus
            potentially be ignored.


        returns:
        -------
        propagated_state_syms: LHS symnbols that need to be evolved
        stationary_state_syms: LHS symbols that don't change (RHS==0)
        indep_syms: symbols appearing on the RHS that aren't state syms, which
            will need to be specified externally.

        Notes:
        ------
        At the moment, this function is mostly aspirational
        """
        state_syms = list(eqD.keys())

        rhs = list(eqD.values())
        rhsSyms = list(sm.Matrix(rhs).free_symbols)
        indep_syms = ut.list_diff(rhsSyms, state_syms)
        stationary_state_syms = [lhs for lhs, rhsin in eqD.items() if rhs == 0]
        propagated_state_syms = ut.list_diff(state_syms, stationary_state_syms)
        return propagated_state_syms, stationary_state_syms, indep_syms

    def set_initial_conditions(self, par0={}, bRealified=False):
        """ Set the initial paramters. The main logic here is to account for different ways they might be expressed.
        Possibilities are:
            * A dictionary of symbol: initial state pairs
            * A list of initial states in the appropriate order
            * An array of initial states, appropriately sized according to all the dimensions
            * The input could be needing to be 'realified' to match the new real-only variables.

        Parameters:
        -----------
        par0: dictionary of {symbol:state} pairs, or an iterable of states (in the right order)
        bRealified: whether it's being specified in the 'realified' format or
            original (potentially) complex format. Relevant only if we're using automatic
            decomposition to real-imaginary parts.
        """
        # Do something to make sure dimensions, order of symbols, are right
        #missing_symbols = set(par0.keys()).difference(self.symsD.prop_state_syms)
        if self.bDecompose_to_re_im and not bRealified:  # We have a complex input, but we're
                                                #doing a real-only sim. Need to map the bits.
            # Map from position in self.state_syms to self.dy_dD
            # Somehow do the mapping based on a dictionary
            # par0:{p1:, p2:, p3:} -> par0{p1r:, p1i:, p2i, p3r:, p3i:}
            # for k in range(len(par0)):
            #    par = par0[k]
            #    realified_par0.append(par.real)
            # pass
            if not isinstance(par0, Mapping): # if it's a list, not a dictionary, we'll make it a dict
                par0 = dict(zip(self.symsD_orig.prop_state_syms, par0))
            par0, _, _ = ut.expand_to_re_im(par0, bNumericalRHS=True)
            #realified_par0 = []

        self.Npars = len(par0)  # Should make sure this matches dy_dtD
        if isinstance(par0, Mapping):
            par0 = [par0[key] for key in self.symsD.prop_state_syms] #order them correctly
                             
        def expand_shape(arr): 
            """Covers the case when arr is a scalar, a full array with same size as the state space, or an array broadcastable to that."""
            if np.array(arr).shape != self.dim_shape:
                arr = arr*np.ones(self.dim_shape, dtype=self.default_dtype)
            return arr

        par0 = np.array([expand_shape(arr) for arr in par0], dtype=self.default_dtype)

        if 0:
            # by now par0 should an iterable of paramters in the required order. Now we'll broadcast it to
            # the other dimensions.
            # Assume a uniform initial state
            if par0.ndim == 1 and len(self.dimAxes) > 0:
                par0 = par0.reshape(-1, *len(self.dimAxes) * [1])
                newShape = (len(self.symsD['prop_state_syms']),
                            *[np.size(ax) for ax in self.dimAxes])
                par0 = np.broadcast_to(par0, newShape)

        self.par0 = par0

    def set_driving(self, t_dep_funcs_D={}):
        """ Set functions that depend only on current value of t

        If they're not callables assume they can be substituted in and sorted out by sympy.
        """
        if not isinstance(driving_funcs_D, Mapping):  # Then we'll assume it's an iterable
            driving_funcs_D = {sym: el for sym, el in zip(
                self.symsD.driving_syms, driving_funcs_D)}
        subsD = {}
        for sym in list(driving_funcs_D.keys()):
            val = driving_funcs_D[sym]

            if not callable(val): #Then maybe it's a sympy expression?
                F= sm.lambdify(self.tSym, val, modules="numpy")
                driving_funcs_D[sym] = F

        if self.bDecompose_to_re_im:  # Split it into two funtions real and imagiunary bits
            driving_funcs_D_ri = {}
            for sym in driving_funcs_D:
                if sym.is_real:
                    driving_funcs_D_ri[sym] = driving_funcs_D[sym]
                else: #This is inefficient, especially for numpy
                    sym_r, sym_i = self.complex_subsD[sym].as_real_imag()
                    f = driving_funcs_D[sym]
                    driving_funcs_D_ri[sym_r] = lambda t: f(t).real
                    driving_funcs_D_ri[sym_i] = lambda t: f(t).imag
            driving_funcs_D = driving_funcs_D_ri

        self.driving_subs_D = subsD
        self.driving_funcs_D = driving_funcs_D
        print(subsD, driving_funcs_D)

    def set_state_dependence(self, stateDepFD={}):
        """Functions that depend on state and time,
        but not history.

        E.g. E_int = E_in*exp(1j*k*z) + cumsum( P(z) )>..
        If they're not callables assume they can be substituted in and sorted out by sympy.
        """
        subsD = {}
        for sym, F in list(stateDepFD.items()): #if it's not callable, assume we can just subtstitue it.
            if not callable(F):
                subsD[sym] = F
                stateDepFD.pop(sym)

        # DECOMPOSE TO REAL/IMAGINARY PARTS-----------------------------------
        if self.bDecompose_to_re_im:  # This is ugly, and ends up calling the function twice. Tensorflow (which is mainly why this exists) may sort it out on the compilation stage though.
            # The fix is to allow a single function to return two symbols, but _not_ done yet
            nDims = len(self.state_shape) - 1
            nStates = len(self.symsD_orig.prop_state_syms)
            nDriving = len(self.symsD_orig.driving_syms)

            which_complex_in = [0] + nDims * [0] + \
                [0 if sym.is_real else 1 for sym in self.symsD_orig['prop_state_syms']] + \
                [0 if sym.is_real else 1 for sym in self.symsD_orig['driving_syms']]
            stateDepFD_ri = {}
            for sym, F in stateDepFD.items(): #so clunky!
                # F_flat takes flattened complex inputs
                F_flat = ut.flatten_inputs(F, nDims, nStates, nDriving)
                which_complex_out = [0 if sym.is_real else 1]
                # F_ri_flat takes flattened real inputs
                F_ri_flat = ut.realify_np(
                    F_flat, which_complex_in, which_complex_out)

                def F_ri(t, dimAxes, states, driving): return F_ri_flat(
                    t, *dimAxes, *states, *driving)

                # def f_r(*args):
                # return F_ri(*args).real
                if sym.is_real:
                    stateDepFD_ri[sym] = lambda *args: F_ri(*args)[0]
                else:
                    sym_r, sym_i = self.complex_subsD[sym].as_real_imag()
                    stateDepFD_ri[sym_r] = lambda *args: F_ri(*args)[0]
                    stateDepFD_ri[sym_i] = lambda *args: F_ri(*args)[1]

            stateDepFD = stateDepFD_ri
        #FINISHED DECOMPOSITION=============================================

        self.stateDepSubsD = subsD
        self.stateDepFD = stateDepFD

    def set_outputs(self, f=None):
        """ This is the function called at every output step. If not given, it'll just output the system state variables.
        """

        def flatten_state(state):
            return state.reshape(-1)  # reshape(self.Npars, -1)

        def unflatten_state(flat_state):
            """Convert from internal sim format to output format"""
            return flat_state.reshape(*self.state_shape)

        if f is None:
            self.outputL = []
            def f2(sim_state):
                res = unflatten_state(sim_state)
                return res
                #self.outputL.append(res)
        else:
            def f2(sim_state):
                state = unflatten_state(sim_state)
                res = f(state)
                return res
                #self.outputL.append(f(state) )

        self._online_process_func = f2

    def setup_model(self, bTryToSimplify=False, bForceStateDimensions=True, subsD = {}, **kwargs):
        """ Do some of the expensive steps required before things can be integrated. Return a model.

        Steps:
            1. Decide which variables are necessary to integrate,
            based on which ones change and which ones are desired as output
            2. Optionally look at initial conditions to see if anything changes based on this.
            3. Compile a dy_dt_fast() function to do the actual integration as fast as possible
            4. Create a function to recreate the desired outputs based on the output of dy_dt_fast

        TODO: this would ideally jsut return an object, all compiled, which can be used for integrating. 
        The interface of the object should be just integrate_to(tEnd), integrate(tSteps), continue(tNext), reset_initial()
        """

        # DO SUBSTITUTIONS
        dy_dtD = self.dy_dtD
        dy_dtD = {sym: ex.subs(self.stateDepSubsD).subs(self.tDepSubsD).subs(subsD)
                  for sym, ex in self.dy_dtD.items()}
        if bTryToSimplify:
            dy_dtD = {sym: ex.simplify() for sym, ex in dy_dtD.items()}
        ##
        if self.bDecompose_to_re_im:
            # Do something to dy_dtD: this should all have been done already
            pass

        # NOTE: This may have some keys/values removed, if they're stationary.
        # Maybe I should just print a warning about this for the moment, rather
        # than trying to optimise automatically? YES, I SHOULD DO THAT FOR THE MOMENT.
        # (At least until I work out if it's actually faster to optimise away)
        # So for now: We can assume that all variables stay in the same order:
        # t, *dims, *state, *driving
        #to_simD = {sym:dy_dtD[sym] for sym in propagated_state_syms}
        #self.d_dt_fast = self.make_d_dt_fast(dy_dtD, self.tDepFD,
                                             #self.stateDepFD, bForceStateDimensions=bForceStateDimensions)
        if self.backend=="numpy":
            D_Dt_Fast = D_Dt_Fast_numpy
        else:
            D_Dt_Fast = D_Dt_Fast_TF
        d_dt_fast = D_Dt_Fast(self.tSym, self.dimSyms, self.dimAxes, dy_dtD, self.tDepFD, self.stateDepFD, bForceStateDimensions=bForceStateDimensions, dtype = self.default_dtype)

        if self._online_process_func is None:
            self.set_outputs()

        self.d_dt_fast = d_dt_fast
        initial_state_flat = self.flatten_state(self.par0)
        if self.backend=="numpy":
            return ModelNumpy(d_dt_fast, initial_state_flat, self._online_process_func, **kwargs)

        def revert(vals):
            """ Add back in the initial conditions for stationary variables

            This will only be useful once we start doing automatic variable removal.
            """
            raise NotImplementedError()
        # if ut.list_diff(state_dep_syms+t_dep_syms, indep_syms) != []
        #    raise ValueError("there are undefined symbols")






if __name__ == "__main__":
    def test_ODESys():
        pass
